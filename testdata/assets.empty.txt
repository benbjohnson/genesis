// Code generated by genesis.
// DO NOT EDIT.

package mypkg

import (
	"bytes"
	"net/http"
	"os"
	"path"
	"regexp"
	"strings"
	"time"
)

var assetMap = map[string]*File{
}

var assetNames = []string{
}

type File struct {
	name    string
	hash    string
	size    int64
	modTime time.Time
	data    []byte
}

func (f *File) Name() string       { return f.name }
func (f *File) Hash() string       { return f.hash }
func (f *File) Size() int64        { return f.size }
func (f *File) ModTime() time.Time { return f.modTime }
func (f *File) Data() []byte       { return f.data }

func Asset(name string) []byte {
	if f := AssetFile(name); f != nil {
		return f.Data()
	}
	return nil
}

func AssetFile(name string) *File {
	if f := assetMap[name]; f != nil {
		return f
	} else if f := assetMap[TrimNameHash(name)]; f != nil {
		return f
	}
	return nil
}

func AssetNames() []string {
	return assetNames
}

func AssetNameWithHash(name string) string {
	if f := AssetFile(name); f != nil {
		return JoinNameHash(f.Name(), f.Hash())
	}
	return name
}

func FileSystem() http.FileSystem { return &httpFileSystem{} }

type httpFileSystem struct{}

func (fs *httpFileSystem) Open(name string) (http.File, error) {
	f := AssetFile(name)
	if f == nil {
		return nil, &os.PathError{Path: "/" + name, Err: os.ErrNotExist}
	}
	return newHTTPFile(f), nil
}

type httpFileServer struct{}

func FileServer() http.Handler {
	return &httpFileServer{}
}

func (h *httpFileServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	name := r.URL.Path
	if !strings.HasPrefix(name, "/") {
		name = "/" + name
		r.URL.Path = name
	}

	f := AssetFile(path.Clean(name))
	if f == nil {
		http.Error(w, "404 page not found", http.StatusNotFound)
		return
	}

	if HasNameHash(name) {
		w.Header().Set("Cache-Control", "max-age=31536000")
	}
	http.ServeContent(w, r, f.Name(), f.ModTime(), newHTTPFile(f))
}

func newHTTPFile(f *File) *httpFile {
	return &httpFile{File: f, Reader: bytes.NewReader(f.data)}
}

type httpFile struct {
	*File
	*bytes.Reader
}

func (f *httpFile) Close() error               { return nil }
func (f *httpFile) Stat() (os.FileInfo, error) { return f, nil }
func (f *httpFile) Size() int64                { return f.File.Size() }
func (f *httpFile) Mode() os.FileMode          { return 0444 }
func (f *httpFile) ModTime() time.Time         { return time.Time{} }
func (f *httpFile) IsDir() bool                { return false }
func (f *httpFile) Sys() interface{}           { return nil }
func (f *httpFile) Readdir(count int) ([]os.FileInfo, error) {
	return nil, &os.PathError{Path: "/" + f.name, Err: os.ErrPermission}
}

func JoinNameHash(name, hash string) string {
	dir, file := path.Split(name)
	if i := strings.Index(file, "."); i != -1 {
		return path.Join(dir, file[0:i]+"-"+hash+file[i:])
	}
	return name + "-" + hash
}

func TrimNameHash(name string) string {
	dir, file := path.Split(name)
	pre, post := file, ""
	if i := strings.Index(file, "."); i != -1 {
		pre, post = file[0:i], file[i:]
	}
	if len(pre) < 41 || pre[len(pre)-41] != '-' || !hashRegex.MatchString(pre[len(pre)-40:]) {
		return name
	}
	return path.Join(dir, pre[:len(pre)-41]+post)
}

func HasNameHash(name string) bool {
	_, file := path.Split(name)
	if i := strings.Index(file, "."); i != -1 {
		file = file[0:i]
	}
	return len(file) >= 41 && file[len(file)-41] == '-' && hashRegex.MatchString(file[len(file)-40:])
}

var hashRegex = regexp.MustCompile("^[0-9a-f]+$")
