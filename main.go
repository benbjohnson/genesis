package main

import (
	"bytes"
	"errors"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"path/filepath"
)

func main() {
	if err := run(os.Args[1:]); err == flag.ErrHelp {
		os.Exit(1)
	} else if err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}

func run(args []string) error {
	// Parse flags.
	fs := flag.NewFlagSet("assetgen", flag.ContinueOnError)
	cwd := fs.String("C", "", "")
	out := fs.String("o", "", "")
	pkg := fs.String("pkg", "", "")
	tags := fs.String("tags", "", "")
	fs.Usage = usage
	if err := fs.Parse(args); err != nil {
		return err
	} else if fs.NArg() == 0 {
		return errors.New("path required")
	} else if *pkg == "" {
		return errors.New("package name required")
	}

	// Change working directory, if specified.
	if *cwd != "" {
		if err := os.Chdir(*cwd); err != nil {
			return err
		}
	}

	// Find all matching files.
	var paths []string
	for _, arg := range fs.Args() {
		a, err := expandPath(arg)
		if err != nil {
			return err
		}
		paths = append(paths, a...)
	}

	// Determine output writer.
	var w io.Writer
	if *out == "" {
		w = os.Stdout
	} else {
		f, err := os.Create(*out)
		if err != nil {
			return err
		}
		defer f.Close()
		w = f
	}

	// Write generated file.
	if err := writeHeader(w, *pkg, *tags); err != nil {
		return err
	} else if err := writeAssetNames(w, paths); err != nil {
		return err
	} else if err := writeAssetMap(w, paths); err != nil {
		return err
	} else if err := writeAssetFuncs(w); err != nil {
		return err
	} else if err := writeFileSystem(w); err != nil {
		return err
	}
	return nil
}

// expandPath converts path into a list of all files within path.
// If path is a file then path is returned.
func expandPath(path string) ([]string, error) {
	if fi, err := os.Stat(path); err != nil {
		return nil, err
	} else if !fi.IsDir() {
		return []string{path}, nil
	}

	// Read files in directory.
	fis, err := ioutil.ReadDir(path)
	if err != nil {
		return nil, err
	}

	// Iterate over files and expand.
	expanded := make([]string, 0, len(fis))
	for _, fi := range fis {
		a, err := expandPath(filepath.Join(path, fi.Name()))
		if err != nil {
			return nil, err
		}
		expanded = append(expanded, a...)
	}
	return expanded, nil
}

func writeHeader(w io.Writer, pkg, tags string) error {
	var buf bytes.Buffer
	fmt.Fprintln(&buf, "// Code generated by assetgen.")
	fmt.Fprintln(&buf, "// DO NOT EDIT.")
	fmt.Fprintln(&buf, "")

	// Write build tags.
	if tags != "" {
		fmt.Fprintf(&buf, "// +build %s\n\n", tags)
		fmt.Fprintln(&buf, "")
	}

	fmt.Fprintf(&buf, "package %s", pkg)
	fmt.Fprintln(&buf, "")

	// Write imports.
	fmt.Fprintln(&buf, "")
	fmt.Fprintln(&buf, `import (`)
	fmt.Fprintln(&buf, `	"bytes"`)
	fmt.Fprintln(&buf, `	"net/http"`)
	fmt.Fprintln(&buf, `	"os"`)
	fmt.Fprintln(&buf, `	"strings"`)
	fmt.Fprintln(&buf, `	"time"`)
	fmt.Fprintln(&buf, `)`)
	fmt.Fprintln(&buf, "")

	_, err := buf.WriteTo(w)
	return err
}

func writeAssetNames(w io.Writer, paths []string) error {
	if _, err := fmt.Fprintln(w, `var assetNames = []string{`); err != nil {
		return err
	}

	for _, path := range paths {
		if _, err := fmt.Fprintf(w, "	%q,\n", filepath.ToSlash(path)); err != nil {
			return err
		}
	}

	_, err := fmt.Fprint(w, "}\n\n")
	return err
}

func writeAssetMap(w io.Writer, paths []string) error {
	if _, err := fmt.Fprintln(w, `var assetMap = map[string][]byte{`); err != nil {
		return err
	}

	for i, path := range paths {
		if _, err := fmt.Fprintf(w, `	%q: []byte("`, filepath.ToSlash(path)); err != nil {
			return err
		} else if err := writeAsset(w, path); err != nil {
			return err
		} else if _, err := fmt.Fprint(w, `"),`+"\n"); err != nil {
			return err
		}

		if i != len(paths)-1 {
			if _, err := fmt.Fprint(w, "\n"); err != nil {
				return err
			}
		}
	}

	_, err := fmt.Fprint(w, "}\n\n")
	return err
}

func writeAssetFuncs(w io.Writer) error {
	var buf bytes.Buffer
	fmt.Fprintln(&buf, `func Asset(name string) []byte { return assetMap[name] }`)
	fmt.Fprintln(&buf, `func AssetNames() []string { return assetNames }`)
	_, err := buf.WriteTo(w)
	return err
}

func writeFileSystem(w io.Writer) error {
	var buf bytes.Buffer
	fmt.Fprintln(&buf, `func FileSystem() http.FileSystem { return &httpFileSystem{} }`)
	fmt.Fprintln(&buf, ``)
	fmt.Fprintln(&buf, `type httpFileSystem struct{}`)
	fmt.Fprintln(&buf, ``)
	fmt.Fprintln(&buf, `func (fs *httpFileSystem) Open(name string) (http.File, error) {`)
	fmt.Fprintln(&buf, `	buf := assetMap[strings.TrimPrefix(name, "/")]`)
	fmt.Fprintln(&buf, `	if buf == nil {`)
	fmt.Fprintln(&buf, `		return nil, &os.PathError{Path: "/" + name, Err: os.ErrNotExist}`)
	fmt.Fprintln(&buf, `	}`)
	fmt.Fprintln(&buf, `	return &httpFile{bytes.NewReader(buf), name, int64(len(buf))}, nil`)
	fmt.Fprintln(&buf, `}`)
	fmt.Fprintln(&buf, ``)
	fmt.Fprintln(&buf, `type httpFile struct {`)
	fmt.Fprintln(&buf, `	*bytes.Reader`)
	fmt.Fprintln(&buf, `	name string`)
	fmt.Fprintln(&buf, `	n    int64`)
	fmt.Fprintln(&buf, `}`)
	fmt.Fprintln(&buf, ``)
	fmt.Fprintln(&buf, `func (f *httpFile) Close() error               { return nil }`)
	fmt.Fprintln(&buf, `func (f *httpFile) Stat() (os.FileInfo, error) { return f, nil }`)
	fmt.Fprintln(&buf, `func (f *httpFile) Name() string               { return f.name }`)
	fmt.Fprintln(&buf, `func (f *httpFile) Size() int64                { return f.n }`)
	fmt.Fprintln(&buf, `func (f *httpFile) Mode() os.FileMode          { return 0444 }`)
	fmt.Fprintln(&buf, `func (f *httpFile) ModTime() time.Time         { return time.Time{} }`)
	fmt.Fprintln(&buf, `func (f *httpFile) IsDir() bool                { return false }`)
	fmt.Fprintln(&buf, `func (f *httpFile) Sys() interface{}           { return nil }`)
	fmt.Fprintln(&buf, `func (f *httpFile) Readdir(count int) ([]os.FileInfo, error) {`)
	fmt.Fprintln(&buf, `	return nil, &os.PathError{Path: "/" + f.name, Err: os.ErrPermission}`)
	fmt.Fprintln(&buf, `}`)

	_, err := buf.WriteTo(w)
	return err
}

func writeAsset(w io.Writer, path string) error {
	f, err := os.Open(path)
	if err != nil {
		return err
	}
	defer f.Close()

	_, err = io.Copy(&hexWriter{w}, f)
	return err
}

// hexWriter converts all writes to \x00 format.
type hexWriter struct {
	w io.Writer
}

func (w *hexWriter) Write(p []byte) (n int, err error) {
	const hex = "0123456789abcdef"
	for _, b := range p {
		var buf [4]byte
		buf[0] = '\\'
		buf[1] = 'x'
		buf[2] = hex[b>>4]
		buf[3] = hex[b&0x0F]

		if _, err := w.w.Write(buf[:]); err != nil {
			return n, err
		}
		n++
	}
	return n, nil
}

func usage() {
	fmt.Println(`usage: assetgen -pkg name [-o output] [-tags tags] path [paths]

Embeds listed assets in a Go file as hex-encoded strings.

The following flags are available:

	-pkg name
		package name of the generated Go file.
	-o output
		output filename for generated code.
		(default stdout)
	-C dir
		execute assetgen from dir.
	-tags tags
		optional comma-delimited list of build tags.
`)
}
